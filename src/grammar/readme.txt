这是语法分析器

其中 is_end_tag 指的是
比如函数 void sayHello(String name) {}
对于参数列表String name来说， )就是它的end tag
也就是不属于参数列表（不受accept）但是却是使它达到结束的标志




架构搭错了：
我的架构是：
链，里面是虎视眈眈的结构生产者，生产者里面有自己的识别机
每一个单元经过的时候，都会被这些生产者所接触，
如果该单元能被生产者所接受，则里面的识别机前进一步，
如果不能被接受，则标记当前状态为不接受任何字符，直至已经有人输出作品
当一个生产者的识别机到达一定状态，确定这些读入的字符串是只有自己所能处理的字符串时，
将输出作品，同时重置所有生产者（包括其识别机），将输出的作品压入栈中。

栈，里面是输出的作品，（其中不乏是半成品，比如"public static void main(" 
虽然知道他是函数，但是为了使的分析的结构清晰，将它分为 public static void main( + args + ){ + clause + }的结构）
这也是上文所造成的，因为每个生产者之间应该是互不干扰的，但是有些生产者不可能一下子就将最后结果输出，比如class语句
所以这里就引入一个半成品（到达Clause条件，比如上文的"("），将半成品输入到栈中）
每一次输入到栈中的作品，将尝试与栈顶元素合并，如果失败则直接push到栈中，如果合并成功，将合并的产物与新栈顶尝试合并（递归）

好处：每个生产者达到互不干扰的，（除了合并步骤，但是也是通过外部传值，并没有直接干涉内部处理）
这为动态添加删除生产者 提供便利，（只需将生产者加入到链中的相应位置）
坏处：有时候输出的半成品，并不是它所希望的类型（过早输出） 比如 ArrayList<Object>,会读成ArrayList < Object(LogicalExpression)
也就是 半成品过早输出的问题（因为一旦输出，链中排在它之后的就得结束，被重置）


收获： 在废墟中另起炉灶（原文是在坟墓中另起炉灶  本次算法的草稿就是写在某讯面试失败的简历上）
先搭设好架构（grammar.Factory  grammar.struct.producer.StructProducer  grammar.struct.Struct）
特别是(unit.UnitFactory  unit.UnitProducer unit.Unit)
再慢慢填：如 unit.producer.*
额，如果还有什么经验得说的话，前期多抽象，少具体
抽象层里面的数据，应该由抽象层自己来管理（比如：grammar.struct.Struct中的clear() & reset()）

Good Luck to you
Mr.Zheng
2015/05/05
